{
    "소프트웨어 설계": [
        {
            "id": 1,
            "question": "소프트웨어 생명주기에서 요구사항 분석 단계에서 사용되는 다이어그램으로, 시스템의 정적 구조를 나타내는 UML 다이어그램은?",
            "answer": "클래스 다이어그램",
            "explanation": "클래스 다이어그램(Class Diagram)은 UML에서 시스템의 클래스, 속성, 메서드, 관계 등을 나타내는 정적 구조 다이어그램입니다."
        },
        {
            "id": 2,
            "question": "객체지향 설계 원칙 중 'Single Responsibility Principle'의 약자는?",
            "answer": "SRP",
            "explanation": "SRP(Single Responsibility Principle)는 '단일 책임 원칙'으로, 하나의 클래스는 하나의 책임만 가져야 한다는 원칙입니다."
        },
        {
            "id": 3,
            "question": "소프트웨어의 설계 품질을 높이기 위한 디자인 패턴 중, 객체 생성을 서브클래스에 위임하는 패턴은?",
            "answer": "팩토리 메소드 패턴",
            "explanation": "팩토리 메소드 패턴(Factory Method Pattern)은 객체 생성을 서브클래스에 위임하여 캡슐화하는 디자인 패턴입니다."
        },
        {
            "id": 4,
            "question": "UML에서 객체들 간의 메시지 교환을 시간 순서에 따라 나타내는 다이어그램은?",
            "answer": "시퀀스 다이어그램",
            "explanation": "시퀀스 다이어그램(Sequence Diagram)은 객체들 간의 메시지 교환을 시간 순서에 따라 표현하는 다이어그램입니다."
        },
        {
            "id": 5,
            "question": "소프트웨어 아키텍처 패턴 중 데이터, 뷰, 컨트롤러로 구성되는 패턴은?",
            "answer": "MVC",
            "explanation": "MVC(Model-View-Controller) 패턴은 모델, 뷰, 컨트롤러로 구성되어 사용자 인터페이스와 비즈니스 로직을 분리하는 패턴입니다."
        },
        {
            "id": 6,
            "question": "객체지향 프로그래밍의 특징이 아닌 것은?",
            "answer": "절차화",
            "explanation": "객체지향 프로그래밍의 주요 특징은 캡슐화, 상속, 다형성, 추상화입니다. 절차화는 절차지향 프로그래밍의 특징입니다."
        },
        {
            "id": 7,
            "question": "GoF 디자인 패턴을 행위, 생성, 구조 패턴으로 분류할 때, Observer 패턴은 어느 분류에 속하는가?",
            "answer": "행위 패턴",
            "explanation": "Observer 패턴은 객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알림을 보내는 행위 패턴입니다."
        },
        {
            "id": 8,
            "question": "코드의 의존성을 역전시켜 상위 모듈이 하위 모듈에 의존하지 않도록 하는 원칙은?",
            "answer": "DIP",
            "explanation": "DIP(Dependency Inversion Principle) 의존성 역전 원칙은 상위 모듈이 하위 모듈에 의존하지 않고 추상화에 의존하도록 하는 원칙입니다."
        },
        {
            "id": 9,
            "question": "소프트웨어 개발 방법론 중 폭포수 모델의 특징이 아닌 것은?",
            "answer": "점진적 개발",
            "explanation": "폭포수 모델은 순차적이고 선형적인 개발 방법론으로, 점진적 개발은 애자일 방법론의 특징입니다."
        },
        {
            "id": 10,
            "question": "UML에서 시스템의 기능을 사용자 관점에서 모델링하는 다이어그램은?",
            "answer": "유스케이스 다이어그램",
            "explanation": "유스케이스 다이어그램(Use Case Diagram)은 시스템의 기능을 사용자(액터) 관점에서 모델링하는 다이어그램입니다."
        },
        {
            "id": 11,
            "question": "객체지향 설계에서 기능의 확장은 열려있고, 수정에는 닫혀있어야 한다는 원칙은?",
            "answer": "OCP",
            "explanation": "OCP(Open/Closed Principle) 개방-폐쇄 원칙은 확장에는 열려있고 변경에는 닫혀있어야 한다는 원칙입니다."
        },
        {
            "id": 12,
            "question": "소프트웨어 요구사항의 특성 중 모호하지 않고 명확하게 표현되어야 한다는 특성은?",
            "answer": "명확성",
            "explanation": "요구사항의 명확성(Clarity)은 모호하지 않고 정확하게 이해할 수 있도록 기술되어야 한다는 특성입니다."
        },
        {
            "id": 13,
            "question": "시스템 분석 단계에서 현재 시스템의 문제점과 요구사항을 파악하는 활동은?",
            "answer": "현행 시스템 분석",
            "explanation": "현행 시스템 분석은 기존 시스템의 기능, 성능, 문제점 등을 파악하여 새로운 시스템의 요구사항을 도출하는 활동입니다."
        },
        {
            "id": 14,
            "question": "소프트웨어 품질 특성 중 시스템이 지정된 조건에서 지정된 기간 동안 장애 없이 수행할 수 있는 능력은?",
            "answer": "신뢰성",
            "explanation": "신뢰성(Reliability)은 소프트웨어가 명시된 조건에서 명시된 기간 동안 요구된 기능을 오류 없이 수행할 수 있는 능력입니다."
        },
        {
            "id": 15,
            "question": "소프트웨어 아키텍처에서 시스템을 독립적인 계층으로 구분하는 패턴은?",
            "answer": "계층 패턴",
            "explanation": "계층 패턴(Layered Pattern)은 시스템을 여러 개의 독립적인 계층으로 구분하여 각 계층이 상위 계층에 서비스를 제공하는 패턴입니다."
        },
        {
            "id": 16,
            "question": "객체 간의 일대다 의존 관계를 정의하여 한 객체의 상태가 변하면 의존 객체들에게 알리는 패턴은?",
            "answer": "옵저버 패턴",
            "explanation": "옵저버 패턴(Observer Pattern)은 한 객체의 상태 변화에 따라 다른 객체들이 자동으로 갱신되도록 하는 행동 패턴입니다."
        },
        {
            "id": 17,
            "question": "소프트웨어 모듈화에서 모듈 내부의 요소들 간의 밀접한 정도를 나타내는 용어는?",
            "answer": "응집도",
            "explanation": "응집도(Cohesion)는 모듈 내부 요소들 간의 관련성 정도를 나타내며, 높을수록 좋은 설계입니다."
        },
        {
            "id": 18,
            "question": "소프트웨어 개발에서 기능을 작은 단위로 나누어 개발하고 통합하는 방식은?",
            "answer": "모듈화",
            "explanation": "모듈화(Modularization)는 소프트웨어를 독립적인 기능 단위로 분할하여 개발하는 기법입니다."
        },
        {
            "id": 19,
            "question": "UML에서 클래스나 객체들 간의 구조적 관계를 나타내는 다이어그램의 공통 특징은?",
            "answer": "정적 모델링",
            "explanation": "UML의 구조 다이어그램들은 시스템의 정적인 구조를 모델링하는 특징을 가집니다."
        },
        {
            "id": 20,
            "question": "소프트웨어 설계에서 인터페이스에 의존해야 하며 구체적인 클래스에 의존하면 안 된다는 원칙은?",
            "answer": "ISP",
            "explanation": "ISP(Interface Segregation Principle) 인터페이스 분리 원칙은 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 한다는 원칙입니다."
        },
        {
            "id": 101,
            "question": "객체를 하나만 생성하도록 보장하고, 어디서든 그 객체에 접근할 수 있도록 하는 디자인 패턴은?",
            "answer": "싱글턴 패턴",
            "explanation": "싱글턴 패턴(Singleton Pattern)은 전역 변수를 사용하지 않고 객체를 단 하나만 생성하도록 보장하여 메모리 낭비를 방지하고 데이터 공유를 쉽게 하는 생성 패턴입니다."
        },
        {
            "id": 102,
            "question": "소프트웨어 모듈화에서 한 모듈이 다른 모듈의 내부 기능이나 데이터를 직접 참조하는, 가장 높은 결합도는?",
            "answer": "내용 결합도",
            "explanation": "내용 결합도(Content Coupling)는 한 모듈이 다른 모듈의 내부를 직접 수정하거나 참조할 때 발생하며, 결합도 중 가장 높고 가장 바람직하지 않습니다."
        },
        {
            "id": 103,
            "question": "UML 다이어그램 중 시스템을 구성하는 물리적인 컴포넌트와 그들 사이의 의존 관계를 표현하는 것은?",
            "answer": "컴포넌트 다이어그램",
            "explanation": "컴포넌트 다이어그램(Component Diagram)은 시스템을 구성하는 물리적인 컴포넌트, 인터페이스, 그리고 그들 간의 관계를 시각적으로 표현하는 구조 다이어그램입니다."
        },
        {
            "id": 104,
            "question": "단일 애플리케이션을 여러 개의 작은 서비스 조합으로 구축하여 각 서비스를 독립적으로 배포하고 확장할 수 있는 아키텍처 스타일은?",
            "answer": "마이크로서비스 아키텍처",
            "explanation": "마이크로서비스 아키텍처(Microservices Architecture)는 각 기능이 독립적인 서비스로 구현되어 유연성과 확장성을 높이는 아키텍처 스타일입니다."
        },
        {
            "id": 105,
            "question": "객체지향 설계 원칙(SOLID) 중 '서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다'는 원칙은?",
            "answer": "LSP",
            "explanation": "LSP(Liskov Substitution Principle) 리스코프 치환 원칙은 자식 클래스가 부모 클래스의 역할을 완전히 대체할 수 있어야 한다는 원칙입니다."
        },
        {
            "id": 106,
            "question": "여러 모듈이 하나의 전역 데이터를 공유하고 수정할 때 발생하는 결합도는?",
            "answer": "공통 결합도",
            "explanation": "공통 결합도(Common Coupling)는 여러 모듈이 하나의 공유 데이터 영역(예: 전역 변수)을 함께 사용할 때 발생하는 결합도입니다."
        },
        {
            "id": 107,
            "question": "애자일 개발 방법론인 스크럼(Scrum)에서 반복적인 개발 주기를 의미하는 용어는?",
            "answer": "스프린트",
            "explanation": "스프린트(Sprint)는 스크럼에서 사용하는 1~4주 단위의 짧은 개발 주기로, 이 기간 동안 계획된 작업을 완료하고 제품의 일부를 개발합니다."
        },
        {
            "id": 108,
            "question": "UML 다이어그램 중 하나의 객체가 가질 수 있는 상태들과 그 상태를 변화시키는 이벤트들을 모델링하는 다이어그램은?",
            "answer": "상태 다이어그램",
            "explanation": "상태 다이어그램(State Diagram)은 객체의 생명주기 동안 발생하는 상태 변화를 시각적으로 모델링하는 동적 다이어그램입니다."
        },
        {
            "id": 109,
            "question": "소프트웨어 요구사항 명세서의 검토 방법으로, 정해진 절차 없이 자유롭게 의견을 나누는 비공식 검토 회의는?",
            "answer": "동료 검토",
            "explanation": "동료 검토(Peer Review)는 개발자들이 동료의 작업 산출물을 검토하며 오류를 찾고 개선 방안을 논의하는 비공식적인 검토 방법입니다."
        },
        {
            "id": 110,
            "question": "소프트웨어 아키텍처의 품질 속성(신뢰성, 성능 등) 간의 상충 관계를 분석하고 평가하는 모델은?",
            "answer": "ATAM",
            "explanation": "ATAM(Architecture Tradeoff Analysis Method)은 소프트웨어 아키텍처가 품질 목표를 얼마나 잘 만족하는지 평가하고, 품질 속성 간의 상충 관계를 분석하는 방법론입니다."
        }
    ],
    "소프트웨어 개발": [
        {
            "id": 21,
            "question": "다음 C 코드의 실행 결과는?\nint a = 10, b = 20;\nprintf(\"%d\", a++ + ++b);",
            "answer": "31",
            "explanation": "a++(후위 증가)는 현재 값 10을 사용한 후 증가, ++b(전위 증가)는 증가 후 값 21을 사용하므로 10 + 21 = 31이 됩니다."
        },
        {
            "id": 22,
            "question": "소스코드를 기계어로 변환하는 과정에서 중간 단계에서 생성되는 코드를 무엇이라고 하는가?",
            "answer": "중간 코드",
            "explanation": "컴파일러는 소스코드를 분석한 후 최적화된 기계어로 변환하기 전에 중간 코드(Intermediate Code)를 생성합니다."
        },
        {
            "id": 23,
            "question": "다음 중 소프트웨어 버전 관리 시스템이 아닌 것은?",
            "answer": "Docker",
            "explanation": "Docker는 컨테이너 기반 가상화 도구이며, Git, SVN, Mercurial 등이 버전 관리 시스템입니다."
        },
        {
            "id": 24,
            "question": "다음 Java 코드의 실행 결과는?\nString str = \"Hello\";\nstr.concat(\" World\");\nSystem.out.println(str);",
            "answer": "Hello",
            "explanation": "String은 불변 객체이므로 concat() 메소드는 새로운 문자열을 반환하지만 str 변수는 변경되지 않습니다."
        },
        {
            "id": 25,
            "question": "다음 Python 코드의 실행 결과는?\nlist1 = [1, 2, 3]\nlist2 = list1\nlist2.append(4)\nprint(len(list1))",
            "answer": "4",
            "explanation": "list2 = list1은 참조 복사이므로 list2를 변경하면 list1도 함께 변경됩니다. 따라서 list1의 길이는 4가 됩니다."
        },
        {
            "id": 26,
            "question": "다음 C++ 코드의 실행 결과는?\nint x = 5;\nint y = ++x * 2;\ncout << y;",
            "answer": "12",
            "explanation": "++x는 x를 먼저 6으로 증가시킨 후 그 값을 사용하므로 y = 6 * 2 = 12가 됩니다."
        },
        {
            "id": 27,
            "question": "메모리 관리에서 동적으로 할당된 메모리를 해제하지 않아 발생하는 문제는?",
            "answer": "메모리 누수",
            "explanation": "메모리 누수(Memory Leak)는 동적으로 할당된 메모리를 프로그램이 해제하지 않아 사용 가능한 메모리가 감소하는 문제입니다."
        },
        {
            "id": 28,
            "question": "다음 Java 코드에서 출력되는 값은?\nint[] arr = {1, 2, 3, 4, 5};\nSystem.out.println(arr[arr.length-1]);",
            "answer": "5",
            "explanation": "arr.length는 5이고, arr[5-1] = arr[4] = 5가 출력됩니다."
        },
        {
            "id": 29,
            "question": "프로그래밍에서 같은 이름의 함수를 매개변수의 타입이나 개수를 다르게 하여 여러 개 정의하는 것은?",
            "answer": "오버로딩",
            "explanation": "오버로딩(Overloading)은 같은 이름의 메소드를 매개변수의 타입, 개수, 순서를 다르게 하여 여러 개 정의하는 것입니다."
        },
        {
            "id": 30,
            "question": "다음 중 절차지향 프로그래밍 언어는?",
            "answer": "C",
            "explanation": "C언어는 대표적인 절차지향 프로그래밍 언어이며, Java, C++, Python 등은 객체지향 언어입니다."
        },
        {
            "id": 31,
            "question": "소프트웨어 개발에서 테스트 주도 개발의 영문 약자는?",
            "answer": "TDD",
            "explanation": "TDD(Test-Driven Development)는 테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 작성하는 개발 방법론입니다."
        },
        {
            "id": 32,
            "question": "다음 Python 코드의 실행 결과는?\ndef func(a=[], b=1):\n    a.append(b)\n    return a\nprint(func())\nprint(func())",
            "answer": "[1]\n[1, 1]",
            "explanation": "Python에서 가변 객체를 기본값으로 사용하면 함수 호출 시마다 같은 객체를 참조하므로 값이 누적됩니다."
        },
        {
            "id": 33,
            "question": "소프트웨어 통합 방식 중 상위 모듈부터 하위 모듈 순으로 통합하는 방식은?",
            "answer": "하향식 통합",
            "explanation": "하향식 통합(Top-down Integration)은 상위 모듈부터 시작하여 하위 모듈을 단계적으로 통합하는 방식입니다."
        },
        {
            "id": 34,
            "question": "코드 리뷰의 주요 목적이 아닌 것은?",
            "answer": "실행 속도 향상",
            "explanation": "코드 리뷰의 주요 목적은 코드 품질 향상, 버그 발견, 지식 공유 등이며, 실행 속도 향상은 직접적인 목적이 아닙니다."
        },
        {
            "id": 35,
            "question": "다음 JavaScript 코드의 실행 결과는?\nvar a = 1;\nfunction test() {\n    console.log(a);\n    var a = 2;\n}\ntest();",
            "answer": "undefined",
            "explanation": "변수 호이스팅에 의해 지역 변수 a가 함수 상단으로 끌어올려지지만 값은 할당되지 않아 undefined가 출력됩니다."
        },
        {
            "id": 36,
            "question": "소프트웨어 모듈 간의 결합도가 가장 낮은(바람직한) 것은?",
            "answer": "자료 결합도",
            "explanation": "자료 결합도(Data Coupling)는 모듈 간에 매개변수를 통해 단순한 자료만 전달하는 가장 바람직한 결합도입니다."
        },
        {
            "id": 37,
            "question": "다음 중 컴파일 타임에 오류를 발견할 수 있는 것은?",
            "answer": "문법 오류",
            "explanation": "문법 오류(Syntax Error)는 컴파일 시점에 발견되는 오류이며, 런타임 오류나 논리 오류는 실행 시에 발견됩니다."
        },
        {
            "id": 38,
            "question": "객체지향 프로그래밍에서 클래스의 인스턴스를 생성하는 특별한 메소드는?",
            "answer": "생성자",
            "explanation": "생성자(Constructor)는 객체가 생성될 때 자동으로 호출되어 객체를 초기화하는 특별한 메소드입니다."
        },
        {
            "id": 39,
            "question": "소프트웨어 개발에서 지속적 통합의 영문 약자는?",
            "answer": "CI",
            "explanation": "CI(Continuous Integration)는 개발자들이 코드 변경사항을 정기적으로 공유 저장소에 통합하는 개발 관행입니다."
        },
        {
            "id": 40,
            "question": "다음 C 코드에서 포인터 p가 가리키는 값은?\nint x = 10;\nint *p = &x;\n*p = 20;\nprintf(\"%d\", x);",
            "answer": "20",
            "explanation": "*p = 20은 포인터 p가 가리키는 메모리 위치(x의 주소)에 20을 저장하므로 x의 값이 20으로 변경됩니다."
        },
        {
            "id": 111,
            "question": "Java 프로젝트의 의존성 관리와 빌드를 자동화하는 대표적인 도구는?",
            "answer": "Maven",
            "explanation": "Maven은 Java 프로젝트의 빌드, 라이브러리 의존성 관리, 문서화 등을 자동화하는 도구입니다. Gradle도 널리 사용됩니다."
        },
        {
            "id": 112,
            "question": "기존 코드의 기능은 변경하지 않으면서 내부 구조를 개선하여 가독성을 높이고 유지보수를 용이하게 하는 작업은?",
            "answer": "리팩토링",
            "explanation": "리팩토링(Refactoring)은 코드의 겉으로 드러나는 동작은 바꾸지 않고 내부 구조를 변경하여 코드의 품질을 향상시키는 과정입니다."
        },
        {
            "id": 113,
            "question": "Python에서 일반 함수와 유사하지만, 값을 반환할 때 `return` 대신 `yield` 키워드를 사용하여 이터레이터를 생성하는 함수는?",
            "answer": "제너레이터",
            "explanation": "제너레이터(Generator)는 `yield`를 사용하여 함수의 실행을 중간에 멈추고 값을 반환했다가, 다시 이어서 실행할 수 있게 하는 특별한 종류의 이터레이터입니다."
        },
        {
            "id": 114,
            "question": "C언어에서 동적으로 할당된 메모리를 해제하는 함수는?",
            "answer": "free",
            "explanation": "`malloc`, `calloc`, `realloc` 함수로 할당된 메모리는 반드시 `free` 함수를 사용하여 해제해야 메모리 누수를 방지할 수 있습니다."
        },
        {
            "id": 115,
            "question": "JavaScript에서 함수와 그 함수가 선언될 당시의 렉시컬 환경의 조합으로, 외부 함수의 변수에 접근할 수 있는 함수를 무엇이라고 하는가?",
            "answer": "클로저",
            "explanation": "클로저(Closure)는 자신이 생성될 때의 환경(스코프)을 기억하는 함수로, 함수가 종료된 후에도 외부 함수의 변수에 접근할 수 있게 해줍니다."
        },
        {
            "id": 116,
            "question": "소스 코드를 실행하지 않고 코드의 잠재적인 오류, 버그, 코딩 스타일 위반 등을 분석하는 도구는?",
            "answer": "정적 분석 도구",
            "explanation": "정적 분석 도구(Static Analysis Tool)는 소스 코드를 실행하지 않고 분석하여 품질을 높이는 데 도움을 줍니다. (예: PMD, SonarQube, Checkstyle)"
        },
        {
            "id": 117,
            "question": "버전 관리 시스템 Git에서 현재 브랜치의 변경 사항을 임시로 저장하고 워킹 디렉토리를 깨끗하게 만드는 명령어는?",
            "answer": "git stash",
            "explanation": "`git stash` 명령어는 아직 커밋하지 않은 변경사항을 스택에 임시로 저장하여 다른 브랜치로 전환하거나 다른 작업을 할 수 있게 해줍니다."
        },
        {
            "id": 118,
            "question": "개발자가 API의 명세를 쉽게 작성하고, 이를 바탕으로 문서를 자동으로 생성하며 테스트까지 할 수 있도록 돕는 프레임워크는?",
            "answer": "Swagger",
            "explanation": "Swagger(현재 OpenAPI Specification)는 RESTful API를 설계, 빌드, 문서화, 사용하는 데 도움을 주는 오픈소스 프레임워크입니다."
        },
        {
            "id": 119,
            "question": "소프트웨어 테스트에서 가장 작은 단위인 함수나 메소드를 개별적으로 검증하는 테스트는?",
            "answer": "단위 테스트",
            "explanation": "단위 테스트(Unit Test)는 소프트웨어의 개별적인 구성 요소(단위)가 의도한 대로 정확하게 작동하는지 검증하는 테스트입니다."
        },
        {
            "id": 120,
            "question": "버전 관리 시스템에서 여러 개발자가 동일한 파일의 같은 부분을 수정했을 때 발생하는 상황은?",
            "answer": "충돌",
            "explanation": "충돌(Conflict)은 버전 관리 시스템이 자동으로 변경 사항을 병합할 수 없을 때 발생하며, 개발자가 직접 수정하여 해결해야 합니다."
        }
    ],
    "데이터베이스 구축": [
        {
            "id": 41,
            "question": "다음 SQL 쿼리의 결과는?\nSELECT COUNT(*) FROM 학생 WHERE 학과='컴퓨터공학' AND 학년=3;",
            "answer": "컴퓨터공학과 3학년 학생 수",
            "explanation": "해당 쿼리는 학과가 '컴퓨터공학'이고 학년이 3인 학생의 수를 계산합니다."
        },
        {
            "id": 42,
            "question": "데이터베이스 정규화 과정에서 이행적 종속(Transitive Dependency)을 제거하는 정규형은?",
            "answer": "3NF",
            "explanation": "제3정규형(3NF)은 제2정규형을 만족하면서 기본키에 속하지 않은 속성들 간의 이행적 종속을 제거한 상태입니다."
        },
        {
            "id": 43,
            "question": "관계형 데이터베이스에서 여러 테이블의 데이터를 결합할 때 사용하는 연산은?",
            "answer": "JOIN",
            "explanation": "JOIN 연산은 두 개 이상의 테이블에서 관련된 튜플들을 결합하는 연산입니다."
        },
        {
            "id": 44,
            "question": "데이터베이스에서 특정 조건을 만족하는 데이터를 검색하는 SQL 구문은?",
            "answer": "SELECT",
            "explanation": "SELECT 문은 데이터베이스에서 조건에 맞는 데이터를 검색하는 SQL 구문입니다."
        },
        {
            "id": 45,
            "question": "데이터베이스의 무결성 제약조건 중 외래키가 참조하는 테이블의 기본키 값이 변경되거나 삭제될 때 외래키를 포함하는 테이블의 처리 방식은?",
            "answer": "참조 무결성",
            "explanation": "참조 무결성(Referential Integrity)은 외래키가 참조하는 테이블의 기본키 값이 존재해야 한다는 제약조건입니다."
        },
        {
            "id": 46,
            "question": "데이터베이스 설계 시 엔티티 간의 관계를 표현하는 방법은?",
            "answer": "ERD",
            "explanation": "ERD(Entity-Relationship Diagram)는 엔티티 간의 관계를 시각적으로 표현하는 다이어그램입니다."
        },
        {
            "id": 47,
            "question": "데이터베이스에서 테이블의 행을 고유하게 식별하는 키는?",
            "answer": "기본키",
            "explanation": "기본키(Primary Key)는 테이블의 각 행을 고유하게 식별하는 역할을 하는 키입니다."
        },
        {
            "id": 48,
            "question": "SQL에서 데이터를 그룹화하고 집계 함수를 적용할 때 사용하는 절은?",
            "answer": "GROUP BY",
            "explanation": "GROUP BY 절은 SQL에서 데이터를 그룹화하고 각 그룹에 집계 함수를 적용할 때 사용됩니다."
        },
        {
            "id": 49,
            "question": "데이터베이스 트랜잭션의 특성 중 완전성을 나타내는 약자는?",
            "answer": "A",
            "explanation": "ACID 특성 중 A(Atomicity, 원자성)는 트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 함을 의미합니다."
        },
        {
            "id": 50,
            "question": "데이터베이스 설계에서 정규화의 주요 목적은?",
            "answer": "데이터 중복 최소화",
            "explanation": "정규화의 주요 목적은 데이터 중복을 최소화하고 데이터 무결성을 유지하는 것입니다."
        },
        {
            "id": 51,
            "question": "데이터베이스에서 여러 개의 SQL 문을 한 번에 실행할 수 있는 객체는?",
            "answer": "저장 프로시저",
            "explanation": "저장 프로시저(Stored Procedure)는 여러 SQL 문을 하나의 단위로 묶어 데이터베이스에 저장하고 실행할 수 있는 객체입니다."
        },
        {
            "id": 52,
            "question": "데이터베이스에서 데이터 조작어(DML)에 해당하지 않는 것은?",
            "answer": "CREATE",
            "explanation": "CREATE는 데이터 정의어(DDL)에 해당하며, DML에는 SELECT, INSERT, UPDATE, DELETE 등이 있습니다."
        },
        {
            "id": 53,
            "question": "데이터베이스에서 인덱스의 주요 목적은?",
            "answer": "검색 속도 향상",
            "explanation": "인덱스(Index)는 데이터의 검색 속도를 향상시키기 위해 사용되는 데이터베이스 객체입니다."
        },
        {
            "id": 54,
            "question": "데이터베이스 설계에서 ER 모델을 관계형 모델로 변환하는 과정은?",
            "answer": "매핑",
            "explanation": "매핑(Mapping)은 ER 모델의 엔티티, 관계, 속성을 관계형 데이터베이스의 테이블, 키, 속성으로 변환하는 과정입니다."
        },
        {
            "id": 55,
            "question": "SQL에서 중복된 행을 제거하기 위해 사용하는 키워드는?",
            "answer": "DISTINCT",
            "explanation": "DISTINCT 키워드는 SQL 쿼리 결과에서 중복된 행을 제거하는 데 사용됩니다."
        },
        {
            "id": 56,
            "question": "데이터베이스에서 뷰(View)의 주요 용도가 아닌 것은?",
            "answer": "성능 향상",
            "explanation": "뷰는 보안, 복잡한 쿼리 단순화, 데이터 독립성 등의 용도로 사용되며, 성능 향상은 주된 목적이 아닙니다."
        },
        {
            "id": 57,
            "question": "데이터베이스에서 특정 컬럼의 값이 NULL인 행을 찾는 조건식은?",
            "answer": "IS NULL",
            "explanation": "IS NULL 연산자는 특정 컬럼의 값이 NULL인 행을 찾는 데 사용됩니다."
        },
        {
            "id": 58,
            "question": "데이터베이스에서 수직 분할을 통해 성능을 향상시키는 기법은?",
            "answer": "수직 파티셔닝",
            "explanation": "수직 파티셔닝(Vertical Partitioning)은 테이블의 컬럼을 분할하여 성능을 향상시키는 기법입니다."
        },
        {
            "id": 59,
            "question": "SQL에서 조건에 따라 다른 값을 반환하는 함수는?",
            "answer": "CASE",
            "explanation": "CASE 문은 SQL에서 조건에 따라 다른 값을 반환하는 함수입니다."
        },
        {
            "id": 60,
            "question": "데이터베이스에서 테이블 간의 관계를 설정하는 제약조건은?",
            "answer": "외래키 제약조건",
            "explanation": "외래키 제약조건(Foreign Key Constraint)은 테이블 간의 관계를 설정하고 참조 무결성을 유지하는 제약조건입니다."
        },
        {
            "id": 121,
            "question": "데이터베이스 트랜잭션의 ACID 특성 중, 트랜잭션이 성공적으로 완료되면 데이터베이스가 항상 일관된 상태를 유지해야 한다는 특성은?",
            "answer": "일관성",
            "explanation": "일관성(Consistency)은 트랜잭션 실행 후에도 데이터베이스가 제약 조건, 규칙 등 명시된 일관성 있는 상태를 유지해야 한다는 특성입니다."
        },
        {
            "id": 122,
            "question": "제3정규형을 만족하면서, 모든 결정자가 후보 키 집합에 속해야 하는 정규형은?",
            "answer": "BCNF",
            "explanation": "BCNF(Boyce-Codd Normal Form)는 모든 결정자가 후보 키인 정규형으로, 제3정규형보다 더 엄격한 조건을 가집니다."
        },
        {
            "id": 123,
            "question": "Key-Value, Document, Column-Family 등 다양한 데이터 모델을 지원하는 비관계형 데이터베이스를 총칭하는 용어는?",
            "answer": "NoSQL",
            "explanation": "NoSQL(Not Only SQL)은 스키마 없이 유연한 데이터 모델을 지원하여 대용량 데이터를 처리하는 데 적합한 비관계형 데이터베이스 시스템입니다."
        },
        {
            "id": 124,
            "question": "SQL에서 테이블의 모든 행을 삭제하지만, 테이블 구조 자체는 남겨두는 명령어는?",
            "answer": "TRUNCATE",
            "explanation": "TRUNCATE TABLE 명령어는 DELETE보다 빠르게 모든 행을 삭제하며, 롤백이 불가능합니다."
        },
        {
            "id": 125,
            "question": "데이터베이스에서 트랜잭션의 모든 변경 내용을 영구적으로 데이터베이스에 반영하는 명령어는?",
            "answer": "COMMIT",
            "explanation": "COMMIT 명령어는 트랜잭션의 성공적인 완료를 선언하고, 변경된 내용을 데이터베이스에 영구적으로 저장합니다."
        },
        {
            "id": 126,
            "question": "여러 사용자가 동시에 데이터베이스에 접근할 때, 데이터의 일관성과 무결성을 유지하기 위한 기법은?",
            "answer": "동시성 제어",
            "explanation": "동시성 제어(Concurrency Control)는 여러 트랜잭션이 동시에 실행될 때 서로 간섭하여 데이터베이스를 손상시키지 않도록 제어하는 기법입니다. (예: 로킹)"
        },
        {
            "id": 127,
            "question": "SQL 문장 안에 포함된 또 다른 SQL 문장을 의미하며, 외부 쿼리의 WHERE 절 등에서 사용되는 쿼리는?",
            "answer": "서브쿼리",
            "explanation": "서브쿼리(Subquery) 또는 부속 질의는 다른 SQL 문 내에 중첩되어 사용되며, 외부 쿼리에 데이터를 제공하는 역할을 합니다."
        },
        {
            "id": 128,
            "question": "데이터 웨어하우스의 특징으로, 데이터가 한 번 저장되면 삭제되거나 변경되지 않는 성질을 무엇이라고 하는가?",
            "answer": "비휘발성",
            "explanation": "비휘발성(Non-Volatile)은 데이터 웨어하우스의 데이터가 시간에 따라 계속 누적되며, 일반적으로 수정이나 삭제 작업이 수행되지 않는 특징을 말합니다."
        },
        {
            "id": 129,
            "question": "관계대수 연산자 중 두 릴레이션에 공통으로 존재하는 튜플을 반환하는 연산은?",
            "answer": "교집합",
            "explanation": "교집합(Intersection, ∩)은 두 릴레이션 모두에 속하는 튜플들로만 구성된 새로운 릴레이션을 반환하는 순수 관계 연산자입니다."
        },
        {
            "id": 130,
            "question": "데이터베이스 시스템의 성능을 최적화하여 응답 시간을 단축하고 처리량을 높이는 작업을 무엇이라고 하는가?",
            "answer": "튜닝",
            "explanation": "데이터베이스 튜닝(Database Tuning)은 쿼리 최적화, 인덱스 재구성, 시스템 파라미터 조정 등을 통해 데이터베이스의 전반적인 성능을 향상시키는 과정입니다."
        }
    ],
    "프로그래밍 언어 활용": [
        {
            "id": 61,
            "question": "다음 Python 코드의 실행 결과는?\nprint([x for x in range(10) if x % 2 == 0])",
            "answer": "[0, 2, 4, 6, 8]",
            "explanation": "이 코드는 0부터 9까지의 숫자 중 짝수만 선택하여 리스트로 반환하는 리스트 컴프리헨션입니다."
        },
        {
            "id": 62,
            "question": "Java에서 다형성(Polymorphism)을 구현하는 방법 중 하나는?",
            "answer": "메소드 오버라이딩",
            "explanation": "메소드 오버라이딩(Method Overriding)은 부모 클래스의 메소드를 자식 클래스에서 재정의하여 다형성을 구현하는 방법입니다."
        },
        {
            "id": 63,
            "question": "JavaScript에서 비동기 처리를 위해 사용되는 객체는?",
            "answer": "Promise",
            "explanation": "Promise는 JavaScript에서 비동기 연산의 최종 완료(또는 실패)와 그 결과값을 나타내는 객체입니다."
        },
        {
            "id": 64,
            "question": "다음 Python 코드의 실행 결과는?\nstring = \"Hello, World!\"\nprint(string[:5])",
            "answer": "Hello",
            "explanation": "Python에서 문자열 슬라이싱 string[:5]는 처음부터 인덱스 4까지의 문자를 추출합니다."
        },
        {
            "id": 65,
            "question": "프로그래밍 언어에서 변수의 스코프(Scope)란?",
            "answer": "변수의 유효 범위",
            "explanation": "스코프(Scope)는 변수가 선언된 위치에 따라 결정되는 변수의 유효 범위를 의미합니다."
        },
        {
            "id": 66,
            "question": "Python에서 딕셔너리 자료형을 정의하는 기호는?",
            "answer": "{}",
            "explanation": "Python에서 딕셔너리는 중괄호({})를 사용하여 정의합니다. 예: {key1: value1, key2: value2}"
        },
        {
            "id": 67,
            "question": "Java에서 예외 처리에 사용되는 키워드가 아닌 것은?",
            "answer": "exit",
            "explanation": "Java의 예외 처리 키워드는 try, catch, finally, throw, throws 등이 있으며, exit는 예외 처리 키워드가 아닙니다."
        },
        {
            "id": 68,
            "question": "다음 중 Python의 자료구조가 아닌 것은?",
            "answer": "Vector",
            "explanation": "Vector는 Python의 기본 자료구조가 아니며, 리스트(List), 튜플(Tuple), 딕셔너리(Dictionary), 집합(Set) 등이 있습니다."
        },
        {
            "id": 69,
            "question": "다음 Python 코드의 실행 결과는?\nprint(sorted([3, 1, 4, 1, 5, 9, 2, 6]))",
            "answer": "[1, 1, 2, 3, 4, 5, 6, 9]",
            "explanation": "sorted() 함수는 인자로 받은 이터러블(여기서는 리스트)을 오름차순으로 정렬한 새로운 리스트를 반환합니다."
        },
        {
            "id": 70,
            "question": "JavaScript에서 변수를 선언하는 키워드 중 블록 스코프를 갖는 것은?",
            "answer": "let",
            "explanation": "let 키워드는 JavaScript에서 블록 스코프를 갖는 변수를 선언하는 키워드입니다."
        },
        {
            "id": 71,
            "question": "다음 Python 코드의 실행 결과는?\ndef func(x, y=[]):\n    y.append(x)\n    return y\nprint(func(1))\nprint(func(2))",
            "answer": "[1]\n[1, 2]",
            "explanation": "Python에서 함수의 기본 인자로 가변 객체를 사용하면, 함수가 호출될 때마다 동일한 객체를 참조하므로 값이 누적됩니다."
        },
        {
            "id": 72,
            "question": "다음 중 Python의 람다 함수를 올바르게 정의한 것은?",
            "answer": "lambda x: x * 2",
            "explanation": "Python의 람다 함수는 lambda 키워드와 매개변수, 콜론, 표현식으로 구성됩니다."
        },
        {
            "id": 73,
            "question": "다음 JavaScript 코드의 실행 결과는?\nconsole.log(typeof null);",
            "answer": "object",
            "explanation": "JavaScript에서 typeof null은 'object'를 반환합니다. 이는 JavaScript의 설계 버그로 알려져 있습니다."
        },
        {
            "id": 74,
            "question": "Python에서 문자열 포맷팅에 사용되는 메소드는?",
            "answer": "format",
            "explanation": "Python에서 문자열 포맷팅에는 format() 메소드, f-문자열, % 연산자 등이 사용됩니다."
        },
        {
            "id": 75,
            "question": "다음 Python 코드의 실행 결과는?\nprint(2 ** 3 + 3 ** 2)",
            "answer": "17",
            "explanation": "2 ** 3은 2의 3제곱으로 8, 3 ** 2는 3의 2제곱으로 9, 따라서 8 + 9 = 17이 출력됩니다."
        },
        {
            "id": 76,
            "question": "Java에서 인터페이스와 추상 클래스의 공통점은?",
            "answer": "구현되지 않은 메소드를 가질 수 있다",
            "explanation": "Java의 인터페이스와 추상 클래스는 모두 구현되지 않은 메소드를 가질 수 있으며, 이를 구현 또는 상속받는 클래스에서 구현해야 합니다."
        },
        {
            "id": 77,
            "question": "다음 중 Python의 모듈 가져오기 문법으로 올바른 것은?",
            "answer": "import math",
            "explanation": "Python에서 모듈을 가져오는 기본 문법은 'import 모듈명'입니다."
        },
        {
            "id": 78,
            "question": "C++에서 참조 변수와 포인터의 차이점 중 하나는?",
            "answer": "참조 변수는 NULL을 가질 수 없다",
            "explanation": "C++의 참조 변수는 선언 시 반드시 초기화해야 하며, NULL을 가질 수 없지만 포인터는 NULL을 가질 수 있습니다."
        },
        {
            "id": 79,
            "question": "Python에서 클래스 상속 시 부모 클래스의 메소드를 호출하는 키워드는?",
            "answer": "super",
            "explanation": "Python에서 super() 키워드는 부모 클래스의 메소드를 호출하는 데 사용됩니다."
        },
        {
            "id": 80,
            "question": "다음 JavaScript 코드의 실행 결과는?\nlet x = 10;\nlet y = '10';\nconsole.log(x == y);\nconsole.log(x === y);",
            "answer": "true\nfalse",
            "explanation": "JavaScript에서 ==는 타입 변환 후 비교하므로 true, ===는 값과 타입을 모두 비교하므로 false가 출력됩니다."
        },
        {
            "id": 131,
            "question": "Python 클래스에서 객체가 생성될 때 초기화를 위해 자동으로 호출되는 특별한 메소드는?",
            "answer": "__init__",
            "explanation": "`__init__` 메소드는 클래스의 생성자(constructor) 역할을 하며, 객체의 인스턴스가 생성될 때 속성을 초기화하는 데 사용됩니다."
        },
        {
            "id": 132,
            "question": "Java에서 더 이상 참조되지 않는 객체를 찾아 메모리에서 자동으로 해제해주는 기능은?",
            "answer": "가비지 컬렉션",
            "explanation": "가비지 컬렉션(Garbage Collection, GC)은 힙(Heap) 메모리 영역에서 사용하지 않는 객체를 자동으로 찾아 제거하여 메모리를 관리하는 기능입니다."
        },
        {
            "id": 133,
            "question": "C++에서 파생 클래스가 기반 클래스의 함수를 재정의할 수 있도록 허용하는 키워드는?",
            "answer": "virtual",
            "explanation": "기반 클래스의 함수에 `virtual` 키워드를 붙이면 가상 함수가 되어, 동적 바인딩을 통해 파생 클래스에서 재정의된 함수가 호출될 수 있습니다. (다형성 구현)"
        },
        {
            "id": 134,
            "question": "JavaScript의 화살표 함수(`=>`)가 일반 함수와 비교했을 때 가지는 특징은?",
            "answer": "자신만의 this를 바인딩하지 않는다",
            "explanation": "화살표 함수는 자신만의 `this`를 갖지 않고, 자신을 감싸고 있는 상위 스코프의 `this`를 그대로 사용합니다."
        },
        {
            "id": 135,
            "question": "Python 함수 정의에서 `*args`와 `**kwargs`가 의미하는 것은?",
            "answer": "가변 인자와 키워드 가변 인자",
            "explanation": "`*args`는 여러 개의 인자를 튜플로 받고, `**kwargs`는 여러 개의 키워드 인자를 딕셔너리로 받아 함수가 가변적인 수의 인자를 처리할 수 있게 합니다."
        },
        {
            "id": 136,
            "question": "프로그램의 타입 검사를 컴파일 시점에 수행하는 언어의 특성은?",
            "answer": "정적 타이핑",
            "explanation": "정적 타이핑(Static Typing) 언어는 컴파일 시점에 변수의 타입을 결정하고 검사하여 실행 전 오류를 발견할 수 있습니다. (예: Java, C++)"
        },
        {
            "id": 137,
            "question": "Java에서 `int` 타입의 변수 a, b에 각각 10, 4가 있을 때 `a / b`의 연산 결과는?",
            "answer": "2",
            "explanation": "Java에서 정수(int) 간의 나눗셈은 소수점 이하를 버리고 정수 부분만 결과로 반환합니다. 따라서 `10 / 4`는 2.5가 아닌 2가 됩니다."
        },
        {
            "id": 138,
            "question": "Python에서 파일을 열어 그 내용 전체를 하나의 문자열로 읽어오는 메소드는?",
            "answer": "read",
            "explanation": "파일 객체의 `read()` 메소드는 파일의 처음부터 끝까지 모든 내용을 읽어 하나의 문자열로 반환합니다."
        },
        {
            "id": 139,
            "question": "프로그램 실행 중에 발생하는 오류를 처리하여 프로그램이 비정상적으로 종료되는 것을 방지하는 메커니즘은?",
            "answer": "예외 처리",
            "explanation": "예외 처리(Exception Handling)는 `try-catch-finally` 등의 구문을 사용하여 런타임에 발생하는 예외 상황에 대처하고 프로그램의 안정성을 높이는 기법입니다."
        },
        {
            "id": 140,
            "question": "부수 효과(Side Effect)가 없고 동일한 입력에 대해 항상 동일한 출력을 반환하는 함수를 무엇이라고 하는가?",
            "answer": "순수 함수",
            "explanation": "순수 함수(Pure Function)는 함수형 프로그래밍의 핵심 개념으로, 외부 상태를 변경하지 않고 입력값에만 의존하여 결과를 만들어내므로 예측 가능하고 테스트가 용이합니다."
        }
    ],
    "정보시스템 구축관리": [
        {
            "id": 81,
            "question": "네트워크에서 IP 주소 변환 기술로, 내부 네트워크와 외부 네트워크 간의 통신을 가능하게 하는 기술은?",
            "answer": "NAT",
            "explanation": "NAT(Network Address Translation)는 사설 IP 주소를 공인 IP 주소로 변환하여 인터넷 접속을 가능하게 하는 기술입니다."
        },
        {
            "id": 82,
            "question": "보안 공격 중 서비스 거부(DoS) 공격의 일종으로, 출발지 IP와 목적지 IP를 동일하게 설정하여 시스템을 마비시키는 공격은?",
            "answer": "Land Attack",
            "explanation": "Land Attack은 출발지 IP와 목적지 IP를 동일하게 설정하여 시스템이 자신에게 무한히 응답하게 만드는 DoS 공격입니다."
        },
        {
            "id": 83,
            "question": "소프트웨어 개발 프로세스에서 요구사항 변경이 빈번할 때 적합한 개발 방법론은?",
            "answer": "애자일 방법론",
            "explanation": "애자일(Agile) 방법론은 변화에 유연하게 대응할 수 있는 반복적이고 점진적인 개발 방법론입니다."
        },
        {
            "id": 84,
            "question": "네트워크 보안에서 특정 포트나 IP 주소로의 접근을 제한하는 시스템은?",
            "answer": "방화벽",
            "explanation": "방화벽(Firewall)은 네트워크 보안에서 특정 포트나 IP 주소로의 접근을 제한하는 시스템입니다."
        },
        {
            "id": 85,
            "question": "소프트웨어 개발 라이프사이클(SDLC)에서 가장 마지막 단계는?",
            "answer": "유지보수",
            "explanation": "유지보수(Maintenance)는 소프트웨어 개발 라이프사이클의 가장 마지막 단계로, 개발 완료 후 시스템을 운영하며 문제를 해결하고 개선하는 단계입니다."
        },
        {
            "id": 86,
            "question": "네트워크 보안에서 패킷의 출발지 주소를 속이는 공격은?",
            "answer": "스푸핑",
            "explanation": "스푸핑(Spoofing)은 공격자가 패킷의 출발지 주소를 속여 다른 시스템으로 위장하는 공격입니다."
        },
        {
            "id": 87,
            "question": "프로젝트 관리에서 프로젝트의 진행 상황을 시각적으로 표현하는 도구는?",
            "answer": "간트 차트",
            "explanation": "간트 차트(Gantt Chart)는 프로젝트의 일정과 진행 상황을 시각적으로 표현하는 바 차트 형태의 도구입니다."
        },
        {
            "id": 88,
            "question": "정보 보안에서 기밀성, 무결성, 가용성을 나타내는 약어는?",
            "answer": "CIA",
            "explanation": "CIA는 정보 보안의 세 가지 핵심 원칙인 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)을 나타냅니다."
        },
        {
            "id": 89,
            "question": "운영체제에서 프로세스 간 통신 방법 중 하나는?",
            "answer": "파이프",
            "explanation": "파이프(Pipe)는 운영체제에서 프로세스 간 통신(IPC)을 위한 방법 중 하나로, 한 프로세스의 출력을 다른 프로세스의 입력으로 연결합니다."
        },
        {
            "id": 90,
            "question": "소프트웨어 테스트에서 소스 코드를 분석하지 않고 수행하는 테스트는?",
            "answer": "블랙박스 테스트",
            "explanation": "블랙박스 테스트는 소프트웨어의 내부 구조나 소스 코드를 알지 못하는 상태에서 수행하는 테스트 방법입니다."
        },
        {
            "id": 91,
            "question": "정보 보안에서 중요 정보를 암호화하는 알고리즘 중 대칭키 방식은?",
            "answer": "AES",
            "explanation": "AES(Advanced Encryption Standard)는 대칭키 암호화 방식으로, 암호화와 복호화에 동일한 키를 사용합니다."
        },
        {
            "id": 92,
            "question": "소프트웨어 개발에서 형상 관리의 주요 목적은?",
            "answer": "변경 관리",
            "explanation": "형상 관리(Configuration Management)의 주요 목적은 소프트웨어 개발 과정에서 발생하는 변경을 체계적으로 관리하는 것입니다."
        },
        {
            "id": 93,
            "question": "네트워크 프로토콜 중 신뢰성 있는 데이터 전송을 보장하는 프로토콜은?",
            "answer": "TCP",
            "explanation": "TCP(Transmission Control Protocol)는 연결 지향적이고 신뢰성 있는 데이터 전송을 보장하는 프로토콜입니다."
        },
        {
            "id": 94,
            "question": "소프트웨어 품질 평가 모델인 ISO/IEC 25010에서 정의하는 품질 특성 중 하나는?",
            "answer": "사용성",
            "explanation": "사용성(Usability)은 ISO/IEC 25010에서 정의하는 소프트웨어 품질 특성 중 하나로, 사용자가 시스템을 얼마나 쉽게 사용할 수 있는지를 나타냅니다."
        },
        {
            "id": 95,
            "question": "네트워크 계층 모델인 OSI 7계층에서 라우팅을 담당하는 계층은?",
            "answer": "네트워크 계층",
            "explanation": "OSI 7계층 모델에서 네트워크 계층(Layer 3)은 패킷의 라우팅을 담당하며, IP 프로토콜이 이 계층에 속합니다."
        },
        {
            "id": 96,
            "question": "소프트웨어 테스트에서 테스트 케이스의 모든 분기와 조건을 최소한 한 번씩 실행하는 커버리지는?",
            "answer": "분기 커버리지",
            "explanation": "분기 커버리지(Branch Coverage)는 프로그램의 모든 분기와 조건을 최소한 한 번씩 실행하는 테스트 커버리지입니다."
        },
        {
            "id": 97,
            "question": "정보 보안에서 사용자의 신원을 확인하는 과정은?",
            "answer": "인증",
            "explanation": "인증(Authentication)은 사용자가 주장하는 신원이 실제로 맞는지 확인하는 과정입니다."
        },
        {
            "id": 98,
            "question": "프로젝트 관리에서 작업 분해도의 영문 약자는?",
            "answer": "WBS",
            "explanation": "WBS(Work Breakdown Structure)는 프로젝트를 관리 가능한 작은 작업 단위로 분해한 계층적 구조입니다."
        },
        {
            "id": 99,
            "question": "네트워크에서 데이터 전송 단위인 패킷의 구성 요소가 아닌 것은?",
            "answer": "프로세스 ID",
            "explanation": "패킷은 일반적으로 헤더, 페이로드(데이터), 트레일러로 구성되며, 프로세스 ID는 패킷의 구성 요소가 아닙니다."
        },
        {
            "id": 100,
            "question": "소프트웨어 아키텍처 패턴 중 프레젠테이션, 도메인 로직, 데이터 접근 계층으로 구성된 패턴은?",
            "answer": "3계층 아키텍처",
            "explanation": "3계층 아키텍처(3-Tier Architecture)는 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 접근 계층으로 구성된 소프트웨어 아키텍처 패턴입니다."
        },
        {
            "id": 141,
            "question": "클라우드 컴퓨팅 서비스 모델 중 서버, 스토리지, 네트워크 등 인프라 자원을 제공하는 서비스는 무엇의 약자인가?",
            "answer": "IaaS",
            "explanation": "IaaS(Infrastructure as a Service)는 가상화된 컴퓨팅 리소스를 인터넷을 통해 제공하는 클라우드 서비스 모델입니다."
        },
        {
            "id": 142,
            "question": "운영체제에서 두 개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다리며 다음 단계로 진행하지 못하는 상태는?",
            "answer": "교착상태",
            "explanation": "교착상태(Deadlock)는 상호 배제, 점유와 대기, 비선점, 환형 대기라는 네 가지 조건이 모두 충족될 때 발생할 수 있습니다."
        },
        {
            "id": 143,
            "question": "웹 애플리케이션의 취약점을 이용해 악의적인 스크립트를 삽입하여, 해당 웹사이트를 방문하는 다른 사용자의 웹 브라우저에서 실행되게 하는 공격 기법은?",
            "answer": "XSS",
            "explanation": "XSS(Cross-Site Scripting) 공격은 사용자의 쿠키나 세션 정보를 탈취하거나 악성 사이트로 리디렉션하는 데 사용될 수 있습니다."
        },
        {
            "id": 144,
            "question": "OSI 7계층 모델에서 종단 간(End-to-End) 신뢰성 있고 정확한 데이터 전송을 담당하는 계층은?",
            "answer": "전송 계층",
            "explanation": "전송 계층(Transport Layer, Layer 4)은 TCP, UDP 프로토콜을 사용하여 데이터 전송의 신뢰성을 보장하고, 포트 번호를 통해 프로세스를 식별합니다."
        },
        {
            "id": 145,
            "question": "여러 대의 서버를 하나로 묶어 마치 하나의 시스템처럼 동작하게 하여 고가용성과 부하 분산을 제공하는 기술은?",
            "answer": "클러스터링",
            "explanation": "클러스터링(Clustering)은 한 서버에 장애가 발생하더라도 다른 서버가 서비스를 계속 제공할 수 있도록 하여 시스템의 안정성과 가용성을 높이는 기술입니다."
        },
        {
            "id": 146,
            "question": "IT 서비스 관리(ITSM) 분야의 모범 사례들을 모아놓은 지식 기반 프레임워크는?",
            "answer": "ITIL",
            "explanation": "ITIL(Information Technology Infrastructure Library)은 IT 서비스를 효과적으로 관리하고 제공하기 위한 프로세스와 절차에 대한 국제적인 표준 프레임워크입니다."
        },
        {
            "id": 147,
            "question": "악의적인 사용자가 웹 애플리케이션의 입력 값에 SQL 쿼리를 삽입하여 데이터베이스를 비정상적으로 조작하는 공격 기법은?",
            "answer": "SQL 인젝션",
            "explanation": "SQL 인젝션(SQL Injection)은 인증을 우회하거나 데이터베이스의 데이터를 유출, 변조, 삭제할 수 있는 매우 위험한 웹 보안 취약점입니다."
        },
        {
            "id": 148,
            "question": "TCP 프로토콜이 통신을 시작하기 전에 상대방과 연결을 설정하는 3단계 과정은?",
            "answer": "3-way-handshake",
            "explanation": "3-way-handshake는 클라이언트가 SYN 패킷을 보내고, 서버가 SYN+ACK 패킷으로 응답하며, 클라이언트가 다시 ACK 패킷을 보내 연결을 확립하는 과정입니다."
        },
        {
            "id": 149,
            "question": "가상 머신(VM)과 비교했을 때, 컨테이너 기술의 가장 큰 장점은?",
            "answer": "가볍고 빠르다",
            "explanation": "컨테이너는 게스트 OS를 포함하지 않고 호스트 OS의 커널을 공유하므로, 가상 머신보다 시작 속도가 빠르고 리소스 사용량이 적어 더 효율적입니다."
        },
        {
            "id": 150,
            "question": "소프트웨어 테스트 레벨 중 개발된 시스템이 사용자의 요구사항을 만족하는지 확인하는 최종 검증 단계는?",
            "answer": "인수 테스트",
            "explanation": "인수 테스트(Acceptance Test)는 실제 사용자가 시스템을 사용하기 전에 요구사항 명세서에 따라 모든 기능이 올바르게 구현되었는지 검증하는 단계입니다."
        }
    ]
}